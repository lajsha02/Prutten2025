\documentclass{article}\usepackage{noweb}\pagestyle{noweb}\noweboptions{}\begin{document}\nwfilename{Suitcase.nw}\nwbegindocs{0}\title{Resväska som \emph{Composite} i Java}% ===> this file was generated automatically by noweave --- better not edit it
\author{Lisa Dahl och Mostafa Shihadeh}

\maketitle
\tableofcontents

\section{Introduktion}
Vi implementerar uppgift 1 (resväska enligt \emph{Composite}-mönstret)
med litterär programmering. Vi bygger tre klasser:
\texttt{Component} (abstrakt), \texttt{Leaf} (pryl) och
\texttt{Composite} (behållare), samt ett testprogram \texttt{Client}.
I X4 lägger vi till två iteratorer (bredden-först och preorder) och gör
\texttt{Composite} itererbar.

\subsection{Designval}
\begin{itemize}
  \item \texttt{Component} bär gemensamma attribut: \texttt{name} och \texttt{weight} (egen vikt).
  \item \texttt{Leaf} representerar en enskild pryl. \texttt{getWeight()} returnerar bara dess egen vikt.
  \item \texttt{Composite} representerar en behållare med barn. \texttt{getWeight()} summerar
        behållarens egen vikt och alla barns vikter. \texttt{toString()} traverserar rekursivt.
  \item Metoderna \texttt{add}/\texttt{remove} finns bara i \texttt{Composite} (inte i \texttt{Component}).
\end{itemize}

\section{Bygga och kompilera}
Precis som i kursens exempel låter vi denna \texttt{.nw} tängla en maskin\-genererad
\texttt{Suitcase.mk} som toppens \texttt{Makefile} \emph{inkluderar}.
Vi använder \texttt{noweave} för PDF och \texttt{notangle} för Java, med
radmarkörer (\texttt{-L}) så \texttt{noerr.pl} kan mappa fel till \texttt{.nw}.

\subsection{Grundmål och PDF-regler}
Vi definierar \texttt{TARGETS}, ett \texttt{all}-mål, samt PDF-reglerna.

\nwenddocs{}\nwbegincode{1}\moddef{Suitcase.mk}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
TARGETS= Suitcase.pdf Suitcase.mk
all: classes Suitcase.pdf

Suitcase.pdf:  Suitcase.tex
  pdflatex -interaction=nonstopmode -halt-on-error Suitcase.tex
  pdflatex -interaction=nonstopmode -halt-on-error Suitcase.tex

Suitcase.tex: Suitcase.nw
  noweave -latex Suitcase.nw > Suitcase.tex
\nwendcode{}\nwbegindocs{2}\nwdocspar

\subsection{Tangle: Java-källor med radmarkörer}
Vi tanglar ut varje \texttt{.java}-fil ur den litterära källan
och bäddar in radmarkörer för bättre felrapporter.

\nwenddocs{}\nwbegincode{3}\moddef{Suitcase.mk}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
Component.java: Suitcase.nw
  notangle -L'//line %L "%F"%N' -RComponent.java Suitcase.nw > Component.java

Leaf.java: Suitcase.nw
  notangle -L'//line %L "%F"%N' -RLeaf.java Suitcase.nw > Leaf.java

Composite.java: Suitcase.nw
  notangle -L'//line %L "%F"%N' -RComposite.java Suitcase.nw > Composite.java

Client.java: Suitcase.nw
  notangle -L'//line %L "%F"%N' -RClient.java Suitcase.nw > Client.java
\nwendcode{}\nwbegindocs{4}\nwdocspar

\subsection{(X4) Tangle: iteratorerna}
Vi tanglar även ut de två iteratorerna.

\nwenddocs{}\nwbegincode{5}\moddef{Suitcase.mk}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
BreadthFirstIterator.java: Suitcase.nw
  notangle -L'//line %L "%F"%N' -RBreadthFirstIterator.java Suitcase.nw > BreadthFirstIterator.java

PreorderIterator.java: Suitcase.nw
  notangle -L'//line %L "%F"%N' -RPreorderIterator.java Suitcase.nw > PreorderIterator.java
\nwendcode{}\nwbegindocs{6}\nwdocspar

\subsection{Kompilera och köra}
Vi samlar Java-byggmålen. Om \texttt{noerr.pl} finns används det;
annars kör vi \texttt{javac} direkt.

\nwenddocs{}\nwbegincode{7}\moddef{Suitcase.mk}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
.PHONY: classes run clean-Suitcase
classes: Component.java Leaf.java Composite.java Client.java BreadthFirstIterator.java PreorderIterator.java
  @if [ -x ./noerr.pl ]; then ./noerr.pl javac *.java; else javac *.java; fi

run: classes
  java Client
\nwendcode{}\nwbegindocs{8}\nwdocspar

\subsection{Städ}
Vi tar bort genererade filer.

\nwenddocs{}\nwbegincode{9}\moddef{Suitcase.mk}\plusendmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
clean: clean-Suitcase
clean-Suitcase:
  rm -f Suitcase.tex Suitcase.aux Suitcase.log Suitcase.toc
  rm -f Suitcase.mk Suitcase.pdf
  rm -f *.class *.java
\nwendcode{}\nwbegindocs{10}\nwdocspar

\section{Kod}
I detta avsnitt definierar vi Javafilerna som tänglas ut.

\subsection{\texttt{Component} (abstrakt)}
\noindent \textbf{Ansvar:} bas-klass med namn och egenvikt samt abstrakta metoder.

Filen {\Tt{}Component.java\nwendquote} ser översiktligt ut så här:

\nwenddocs{}\nwbegincode{11}\moddef{Component.java}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
public abstract class Component \{
  \LA{}Component attributes\RA{}
  \LA{}Component constructor\RA{}
  \LA{}Component methods\RA{}
\}
\nwendcode{}\nwbegindocs{12}\nwdocspar

\subsubsection{Attribut}
Vi vill att \texttt{Component} ska ha följande attribut:
\begin{itemize}
  \item \texttt{name}: namn på komponenten (sträng)
  \item \texttt{weight}: egen vikt i kg (flyttal)
\end{itemize}
Dessa är \emph{protected final}.

\nwenddocs{}\nwbegincode{13}\moddef{Component attributes}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  protected final String name;
  protected final double weight;
\nwendcode{}\nwbegindocs{14}\nwdocspar

\subsubsection{Konstruktor}
Vi kontrollerar att namnet inte är tomt och att vikten är icke-negativ.

\nwenddocs{}\nwbegincode{15}\moddef{Component constructor}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  protected Component(String name, double weight) \{
    if (name == null || name.isBlank()) throw new IllegalArgumentException("name");
    if (weight < 0) throw new IllegalArgumentException("weight");
    this.name = name;
    this.weight = weight;
  \}
\nwendcode{}\nwbegindocs{16}\nwdocspar

\subsubsection{Metoder}
Vi exponerar \texttt{getName} och \texttt{getOwnWeight}. De abstrakta metoderna
\texttt{getWeight} och \texttt{toString} implementeras i subklasser.

\nwenddocs{}\nwbegincode{17}\moddef{Component methods}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  public String getName() \{ return name; \}
  public double getOwnWeight() \{ return weight; \}
  public abstract double getWeight();
  @Override public abstract String toString();
\nwendcode{}\nwbegindocs{18}\nwdocspar

\subsection{\texttt{Leaf}}
\noindent \textbf{Ansvar:} en enskild pryl att packa.

Filen {\Tt{}Leaf.java\nwendquote} ser översiktligt ut så här:

\nwenddocs{}\nwbegincode{19}\moddef{Leaf.java}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
public class Leaf extends Component \{
  \LA{}Leaf constructor\RA{}
  \LA{}Leaf methods\RA{}
\}
\nwendcode{}\nwbegindocs{20}\nwdocspar

\subsubsection{Konstruktor}
Konstruktorn tar namn och egen vikt och skickar vidare till \texttt{Component}.

\nwenddocs{}\nwbegincode{21}\moddef{Leaf constructor}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  public Leaf(String name, double weight) \{
    super(name, weight);
  \}
\nwendcode{}\nwbegindocs{22}\nwdocspar

\subsubsection{Metoder}
Totalvikten för ett löv är samma som dess egen vikt. \texttt{toString} beskriver prylen.

\nwenddocs{}\nwbegincode{23}\moddef{Leaf methods}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  @Override
  public double getWeight() \{
    return this.weight;
  \}

  @Override
  public String toString() \{
    return this.name + " (" + this.weight + " kg)";
  \}
\nwendcode{}\nwbegindocs{24}\nwdocspar

\subsection{\texttt{Composite}}
\noindent \textbf{Ansvar:} en behållare som kan innehålla andra \texttt{Component}.
Egen vikt \emph{plus} alla barns vikter utgör totalvikten. I X4 gör vi den även
\emph{itererbar} så att for-each fungerar (default: BFS).

Filen {\Tt{}Composite.java\nwendquote} ser översiktligt ut så här:

\nwenddocs{}\nwbegincode{25}\moddef{Composite.java}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

public class Composite extends Component implements Iterable<Component> \{
  \LA{}Composite fields\RA{}
  \LA{}Composite constructor\RA{}
  \LA{}Composite child-management\RA{}
  \LA{}Composite weight\RA{}
  \LA{}Composite toString\RA{}
  \LA{}Composite iterability\RA{}
\}
\nwendcode{}\nwbegindocs{26}\nwdocspar

\subsubsection{Fält}
Vi lagrar barn i en muterbar lista, men exponerar en oföränderlig vy utåt.

\nwenddocs{}\nwbegincode{27}\moddef{Composite fields}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  private final List<Component> children = new ArrayList<>();
\nwendcode{}\nwbegindocs{28}\nwdocspar

\subsubsection{Konstruktor}
Konstruktorn tar behållarens namn och egen vikt.

\nwenddocs{}\nwbegincode{29}\moddef{Composite constructor}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  public Composite(String name, double ownWeight) \{
    super(name, ownWeight);
  \}
\nwendcode{}\nwbegindocs{30}\nwdocspar

\subsubsection{Barnhantering (\texttt{add}/\texttt{remove}/\texttt{getChildren})}
Vi kan lägga till och ta bort barn, och ge tillbaka en oföränderlig vy av listan.

\nwenddocs{}\nwbegincode{31}\moddef{Composite child-management}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  public void add(Component c) \{
    if (c == null) throw new IllegalArgumentException("child");
    children.add(c);
  \}

  public void remove(Component c) \{
    children.remove(c);
  \}

  public List<Component> getChildren() \{
    return Collections.unmodifiableList(children);
  \}
\nwendcode{}\nwbegindocs{32}\nwdocspar

\subsubsection{Totalvikt (\texttt{getWeight})}
Totalvikt = egen vikt + summan av alla barns totalvikter (rekursivt).

\nwenddocs{}\nwbegincode{33}\moddef{Composite weight}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  @Override
  public double getWeight() \{
    double sum = this.weight;
    for (Component c : children) \{
      sum += c.getWeight();
    \}
    return sum;
  \}
\nwendcode{}\nwbegindocs{34}\nwdocspar

\subsubsection{\texttt{toString}}
Vi bygger en rekursiv beskrivning där barn listas inom hakparenteser.

\nwenddocs{}\nwbegincode{35}\moddef{Composite toString}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  @Override
  public String toString() \{
    StringBuilder sb = new StringBuilder();
    sb.append(this.name).append(" (").append(this.weight).append(" kg) [");
    for (int i = 0; i < children.size(); i++) \{
      sb.append(children.get(i).toString());
      if (i < children.size() - 1) sb.append(", ");
    \}
    sb.append("]");
    return sb.toString();
  \}
\nwendcode{}\nwbegindocs{36}\nwdocspar

\subsubsection{Itererbarhet (X4)}
Vi gör \texttt{Composite} \texttt{Iterable<Component>}. Default\-iteratorn är BFS.
Vi lägger även metoder för explicit BFS respektive preorder.

\nwenddocs{}\nwbegincode{37}\moddef{Composite iterability}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  @Override
  public Iterator<Component> iterator() \{
    return new BreadthFirstIterator(this);
  \}

  public Iterator<Component> breadthFirstIterator() \{
    return new BreadthFirstIterator(this);
  \}

  public Iterator<Component> preorderIterator() \{
    return new PreorderIterator(this);
  \}
\nwendcode{}\nwbegindocs{38}\nwdocspar

\subsection{\texttt{BreadthFirstIterator} (X4)}
\noindent \textbf{Ansvar:} leverera noder i bredden-först-ordning (rot, alla barn, barnbarn, \ldots).

Filen {\Tt{}BreadthFirstIterator.java\nwendquote} ser översiktligt ut så här:

\nwenddocs{}\nwbegincode{39}\moddef{BreadthFirstIterator.java}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class BreadthFirstIterator implements Iterator<Component> \{
  \LA{}BFS fields\RA{}
  \LA{}BFS ctor\RA{}
  \LA{}BFS hasNext\RA{}
  \LA{}BFS next\RA{}
  \LA{}BFS remove\RA{}
\}
\nwendcode{}\nwbegindocs{40}\nwdocspar

\subsubsection{Fält}
Vi använder en kö (\texttt{ArrayDeque}) av \texttt{Component}.

\nwenddocs{}\nwbegincode{41}\moddef{BFS fields}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  private final Deque<Component> queue = new ArrayDeque<>();
\nwendcode{}\nwbegindocs{42}\nwdocspar

\subsubsection{Konstruktor}
Vi startar med roten.

\nwenddocs{}\nwbegincode{43}\moddef{BFS ctor}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  public BreadthFirstIterator(Component root) \{
    if (root == null) throw new IllegalArgumentException("root");
    queue.add(root);
  \}
\nwendcode{}\nwbegindocs{44}\nwdocspar

\subsubsection{\texttt{hasNext}}
\nwenddocs{}\nwbegincode{45}\moddef{BFS hasNext}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  @Override
  public boolean hasNext() \{
    return !queue.isEmpty();
  \}
\nwendcode{}\nwbegindocs{46}\nwdocspar

\subsubsection{\texttt{next}}
Om elementet är \texttt{Composite}, läggs dess barn sist i kön.

\nwenddocs{}\nwbegincode{47}\moddef{BFS next}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  @Override
  public Component next() \{
    if (queue.isEmpty()) throw new NoSuchElementException();
    Component current = queue.removeFirst();
    if (current instanceof Composite) \{
      for (Component child : ((Composite) current).getChildren()) \{
        queue.addLast(child);
      \}
    \}
    return current;
  \}
\nwendcode{}\nwbegindocs{48}\nwdocspar

\subsubsection{\texttt{remove}}
Inte del av labbkraven.

\nwenddocs{}\nwbegincode{49}\moddef{BFS remove}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  @Override
  public void remove() \{
    throw new UnsupportedOperationException();
  \}
\nwendcode{}\nwbegindocs{50}\nwdocspar

\subsection{\texttt{PreorderIterator} (X4)}
\noindent \textbf{Ansvar:} leverera noder i preorder (djupet-först): rot, sedan rekursivt barn vänster→höger.

Filen {\Tt{}PreorderIterator.java\nwendquote} ser översiktligt ut så här:

\nwenddocs{}\nwbegincode{51}\moddef{PreorderIterator.java}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

public class PreorderIterator implements Iterator<Component> \{
  \LA{}PRE fields\RA{}
  \LA{}PRE ctor\RA{}
  \LA{}PRE hasNext\RA{}
  \LA{}PRE next\RA{}
  \LA{}PRE remove\RA{}
\}
\nwendcode{}\nwbegindocs{52}\nwdocspar

\subsubsection{Fält}
Stack över \texttt{Component} som ska besökas.

\nwenddocs{}\nwbegincode{53}\moddef{PRE fields}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  private final Deque<Component> stack = new ArrayDeque<>();
\nwendcode{}\nwbegindocs{54}\nwdocspar

\subsubsection{Konstruktor}
Börja med roten överst på stacken.

\nwenddocs{}\nwbegincode{55}\moddef{PRE ctor}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  public PreorderIterator(Component root) \{
    if (root == null) throw new IllegalArgumentException("root");
    stack.push(root);
  \}
\nwendcode{}\nwbegindocs{56}\nwdocspar

\subsubsection{\texttt{hasNext}}
\nwenddocs{}\nwbegincode{57}\moddef{PRE hasNext}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  @Override
  public boolean hasNext() \{
    return !stack.isEmpty();
  \}
\nwendcode{}\nwbegindocs{58}\nwdocspar

\subsubsection{\texttt{next}}
Poppa ett element; om \texttt{Composite}, lägg dess barn på stacken i \emph{omvänd} ordning.

\nwenddocs{}\nwbegincode{59}\moddef{PRE next}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  @Override
  public Component next() \{
    if (stack.isEmpty()) throw new NoSuchElementException();
    Component current = stack.pop();
    if (current instanceof Composite) \{
      List<Component> children = ((Composite) current).getChildren();
      for (int i = children.size() - 1; i >= 0; i--) \{
        stack.push(children.get(i));
      \}
    \}
    return current;
  \}
\nwendcode{}\nwbegindocs{60}\nwdocspar

\subsubsection{\texttt{remove}}
Inte del av labbkraven.

\nwenddocs{}\nwbegincode{61}\moddef{PRE remove}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
  @Override
  public void remove() \{
    throw new UnsupportedOperationException();
  \}
\nwendcode{}\nwbegindocs{62}\nwdocspar

\subsection{\texttt{Client}}
\noindent \textbf{Ansvar:} bygga en resväska med minst tre nivåer och minst tio prylar,
skriva ut totalvikt och innehåll, ta bort några objekt, och skriva ut igen.
I X4 demonstrerar vi även traversal i BFS och preorder.

Filen {\Tt{}Client.java\nwendquote} ser översiktligt ut så här:

\nwenddocs{}\nwbegincode{63}\moddef{Client.java}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
public class Client \{
  public static void main(String[] args) \{
    \LA{}Client build-structure\RA{}
    \LA{}Client print-before\RA{}
    \LA{}Client removals\RA{}
    \LA{}Client print-after\RA{}
    \LA{}Client iterate-bfs\RA{}
    \LA{}Client iterate-preorder\RA{}
  \}
\}
\nwendcode{}\nwbegindocs{64}\nwdocspar

\subsubsection{Bygg upp strukturen (\texttt{suitcase})}
Vi skapar roten (resväskan), underbehållare och löv.

\nwenddocs{}\nwbegincode{65}\moddef{Client build-structure}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
    // Roten: själva resväskan (egen vikt 2.3 kg)
    Composite suitcase = new Composite("Resväska", 2.3);

    // Större plagg (löven)
    Leaf tshirt1 = new Leaf("T-shirt vit", 0.18);
    Leaf tshirt2 = new Leaf("T-shirt svart", 0.19);
    Leaf jeans   = new Leaf("Jeans", 0.75);
    Leaf chinos  = new Leaf("Chinos", 0.55);
    Leaf bok     = new Leaf("Pocketbok", 0.28);

    // Necessär (behållare) med egen vikt 0.12 kg och innehåll
    Composite necessar = new Composite("Necessär", 0.12);
    Leaf tvål     = new Leaf("Tvål", 0.09);
    Leaf schampo  = new Leaf("Schampo", 0.22);
    Leaf borste   = new Leaf("Tandborste", 0.03);
    Leaf tandkräm = new Leaf("Tandkräm", 0.11);
    necessar.add(tvål);
    necessar.add(schampo);
    necessar.add(borste);
    necessar.add(tandkräm);

    // Påse i necessären (tredje nivån)
    Composite påse = new Composite("Påse", 0.01);
    Leaf hårspännen = new Leaf("Hårspännen (10 st)", 0.02);
    påse.add(hårspännen);
    necessar.add(påse);

    // Mindre väska för elektronik (behållare) — nivå två
    Composite techbag = new Composite("Tech-väska", 0.20);
    Leaf laddare  = new Leaf("Laddare", 0.15);
    Leaf hörlurar = new Leaf("Hörlurar", 0.08);
    Leaf powerbank = new Leaf("Powerbank", 0.18);
    techbag.add(laddare);
    techbag.add(hörlurar);
    techbag.add(powerbank);

    // Packa allt i resväskan
    suitcase.add(tshirt1);
    suitcase.add(tshirt2);
    suitcase.add(jeans);
    suitcase.add(chinos);
    suitcase.add(bok);
    suitcase.add(necessar);
    suitcase.add(techbag);
\nwendcode{}\nwbegindocs{66}\nwdocspar

\subsubsection{Skriv ut totalvikt och innehåll (före borttagning)}
\nwenddocs{}\nwbegincode{67}\moddef{Client print-before}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
    System.out.printf("Totalvikt före borttagning: %.2f kg%n", suitcase.getWeight());
    System.out.println("Innehåll före borttagning:");
    System.out.println(suitcase.toString());
\nwendcode{}\nwbegindocs{68}\nwdocspar

\subsubsection{Ta bort några saker/behållare}
Vi tar bort en pryl i en behållare, hela teknikväskan och påsen i necessären.

\nwenddocs{}\nwbegincode{69}\moddef{Client removals}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
    techbag.remove(powerbank);      // ta bort en pryl i behållare
    suitcase.remove(techbag);       // ta bort hela behållaren
    necessar.remove(påse);          // ta bort tredje nivåns behållare
\nwendcode{}\nwbegindocs{70}\nwdocspar

\subsubsection{Skriv ut totalvikt och innehåll (efter borttagning)}
\nwenddocs{}\nwbegincode{71}\moddef{Client print-after}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
    System.out.printf("Totalvikt efter borttagning: %.2f kg%n", suitcase.getWeight());
    System.out.println("Innehåll efter borttagning:");
    System.out.println(suitcase.toString());
\nwendcode{}\nwbegindocs{72}\nwdocspar

\subsubsection{(X4) Traversal: Bredden-först (for-each) och preorder}
Vi skriver ut \emph{endast nodernas namn} med \texttt{getName()} så att ordningen syns tydligt.

\nwenddocs{}\nwbegincode{73}\moddef{Client iterate-bfs}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
    System.out.println("Bredden-först (default for-each):");
    for (Component co : suitcase) \{              // Composite.iterator() = BFS
      System.out.print(co.getName() + " ");
    \}
    System.out.println();
\nwendcode{}\nwbegindocs{74}\nwdocspar

\nwenddocs{}\nwbegincode{75}\moddef{Client iterate-preorder}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
    System.out.println("Preorder (djupet-först):");
    java.util.Iterator<Component> it = new PreorderIterator(suitcase);
    while (it.hasNext()) \{
      System.out.print(it.next().getName() + " ");
    \}
    System.out.println();
\nwendcode{}\nwbegindocs{76}\nwdocspar

\section{Bygginstruktion}
Kör \texttt{make} (eller \texttt{make classes}) för att kompilera Java.
Kör \texttt{make run} för att köra demon.
Kör \texttt{make Suitcase.pdf} för att generera PDF:en.
\nwenddocs{}\end{document}

